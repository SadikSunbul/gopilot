package clients

import (
	"context"
	"errors"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

type GeminiClient struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

func NewGeminiClient(apiKey string, genaiModel string) (*GeminiClient, error) {
	if apiKey == "" {
		return nil, errors.New("API key required")
	}

	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return nil, err
	}

	if genaiModel == "" {
		genaiModel = "gemini-2.0-flash"
	}

	model := client.GenerativeModel(genaiModel)

	// Configure the model
	model.ResponseMIMEType = "application/json"

	// This will be generated by a system structure - This is the system prompt
	systemPrompt := `You are an agent selector and parameter determiner.
Based on the user's request, select the appropriate agent from the following list and specify the required parameters.

IMPORTANT RULES:
1. Only select translate-agent if the user EXPLICITLY asks for translation
2. Do not assume translation is needed just because the text is in a different language
3. For general questions or discussions in any language, use the appropriate agent based on the intent, not the language

Available agents and their parameters:
1. weather-agent:
   - city: string (city name)

2. translate-agent:
   - text: string (text to translate)
   - from: string (source language code, e.g., "tr", "en")
   - to: string (target language code)

3. calculator-agent:
   - expression: string (mathematical expression)

If the user's request doesn't match any of these agents, use the "unsupported" agent in your response.

Provide your response ONLY in the following JSON format, without any additional text:
{
    "agent": "agent-name",
    "parameters": {
        "parameter1": "value1"
    }
}`
	model.SystemInstruction = genai.NewUserContent(genai.Text(systemPrompt))

	return &GeminiClient{
		client: client,
		model:  model,
	}, nil
}

func (g *GeminiClient) Generate(prompt string) (string, error) {
	ctx := context.Background()

	resp, err := g.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return "", err
	}

	if len(resp.Candidates) == 0 {
		return "", errors.New("response not generated")
	}

	return string(resp.Candidates[0].Content.Parts[0].(genai.Text)), nil
}

func (g *GeminiClient) Stream(prompt string) (<-chan string, error) {
	ctx := context.Background()
	outputChan := make(chan string)

	stream := g.model.GenerateContentStream(ctx, genai.Text(prompt))

	go func() {
		defer close(outputChan)
		for {
			resp, err := stream.Next()
			if err != nil {
				break
			}
			if len(resp.Candidates) > 0 {
				text := string(resp.Candidates[0].Content.Parts[0].(genai.Text))
				outputChan <- text
			}
		}
	}()

	return outputChan, nil
}

func (g *GeminiClient) Close() error {
	return g.client.Close()
}
